## Важные особенности Эрланг

Изначально, еще до разработки эрланг, были сформулированы требования к языку:
- Concurrency -- эффективная реализация многопоточности
- Fault Tolerance -- устойчивость к программным и аппаратным сбоям
- Distribution -- поддержка распределенных систем
- Hot Code Upgrade -- возможность горячего обновления кода

К этим 4-м столпам, описанным во всех книгах по эрланг, я добавлю еще несколько фич:
- Symmetric Multiprocessing
- Actor Model
- Soft Real Time
- Garbage Collection
- Erlang Shell
- Tracing

Сердцем Erlang является Erlang Run-Time System (ERTS) -- виртуальная машина, которая выполняет байт-код эрланг.
Реализована на С, и все описанные ниже фичи обеспечиваются ей.


### Concurrency

Процессы являются базовой сущностью языка.

Процессы легковесны, их можно создавать десятки и сотни тысяч. Переключение между ними очень быстрое.

Нет разделяемой области памяти, каждый процесс имеет свою изолированную память.

Ошибки в процессах также изолированы, падение одного процесса не влияет на работу остальных.

Данные между процессами передаются путем "отправки сообщений" (message passing).
При этом данные копируются из памяти одного процесса в память другого.

1024 - 134,217,727 (2^10 - 2^27)
дефолтное значение 262,144 (2^18)

Запуск нового процесса - 3-5 микросекунд.

На старте поток занимает 2696 байт, включая стек, кучу и память под свои метаданные
(потом резервирует больше памяти, если нужно).

Запускается несколько планировщиков, соответственно количеству процессорных ядер.
Каждый планировщик использует один процесс ОС, и поверх него запускает эрланговские процессы.

Планировщики умеют балансировать нагрузку, перераспределяя потоки между собой.
У них нет задачи постоянно держать равномерную нагрузку на все ядра процессоров,
но есть задача избежать больших перекосов, когда одно ядро загружено на 100%, а другое вообще простаивает.

Lukas Larsson - Understanding the Erlang Scheduler
https://www.youtube.com/watch?v=tBAM_N9qPno


### Fault Tolerance

Большинство языков для этого предлагает механизм исключений. И
разработчик может получить относительно безопасный код, если правильно
расставит try…catch и правильно обработает ошибки.

В Erlang это тоже есть, но это только первый уровень изоляции
ошибок. И он довольно редко используется, из-за того, что другие
уровни работают хорошо. Если вы возьмете исходники какого-нибудь
крупного известного эрланг проекта, например, Cowboy или Riak, и
поищите там try..catch, то найдете их очень мало.

Вторым уровнем является дерево супервизоров. В Erlang есть специальные
потоки, которые сами не выполняют полезной работы, а наблюдают за
другими. Такие специальные потоки называются supervisor
(наблюдатели). Ну а потоки, которые выполняют реальную работу,
называются worker (рабочие).

Если в рабочем потоке возникает ошибка, он аварийно
завершается. Супервизор получает об этом сообщение, и может принять
какие-то меры. Стандартная мера – логировать ошибку и перезапустить
рабочий поток заново. При этом мы имеем потери -- текущее состояние
памяти потока, но можем продолжать работу.

Супервизоры наблюдают не только за рабочими процессами, но и друг за
другом. Для этого все потоки организованы в дерево, где узлами
являются супервизоры, а листьями – рабочие потоки.  В более сложной
ситуации можно перегрузить всю ветвь дерева, выше и выше по уровню. И,
наконец, все дерево целиком.

Третий уровень изоляции ошибок – объединение узлов в кластер. Если узел
все-таки падает, или вообще сервер выходит из строя из-за проблем с
железом, то его функцию может взять на себя резервный узел.


### Distribution

A distributed system is one in which the failure of a computer you didn’t even know existed can render your own computer unusable.
Leslie Lamport.

Устойчивость в т.ч. и к аппаратным авариям является одним из требований к эрланг.
И обеспечить эту устойчивость можно только в распределенной системе.

Железо выходит из строя не так часто, но это случается.
Если инфраструктура состоит из сотен серверов, то это случается регулярно, и является штатной ситуацией.

2 цели:
- горизонтальное масштабирование
- устойчивость к авариям

Сетевая прозрачность (location transparency)

Процессы общаются отправкой сообщений друг другу, при этом не важно,
находятся ли они на одном узле, или на разных.

За реализацию отвечает виртуальная машина. Она сама открывает сокеты,
устанавливает нужные TCP соединения между узлами, мониторит их
состояние – программисту об этих низкоуровневых вещах думать не нужно.

Сетевая прозрачность касается не только отправки сообщений, но и мониторинга процессов.
Supervisor может запускать и мониторить worker на другом узле.

эрланг-узлы, собранные в кластер, формируют доверенную среду (trusted environment).
Нет ограничения прав. Любой процесс может посылать любые сообщения кому угодно.
Это удобно, но не безопасно.
Подразумевается, что все узлы находятся в одной локальной сети,
и сеть защищена от внешнего мира.


### Hot Code Upgrade

Эрланг позволяет загрузить в рантайм новую версию кода модуля,
и переключить выполнение процесса со старой версии на новую,
сохранив состояние его памяти.

Если в коде изменились структуры данных,
то есть способ мигрировать данные из старой структуры в новую.

Еще может измениться дерево супервизоров, и нужно стартовать новые процессы,
или завершать старые.

Эти проблемы так или иначе решаются.


### Symmetric Multiprocessing

С 2006 года одна эрланг умеет эффективно использовать все процессорные ядра в системе,
и перераспределять нагрузку между ними.

То есть, процесс, запущенный под одним планировщиком, на одном процессорном ядре, может быть
передан под управление другому планировщику, и продолжить выполнение на другом процессором ядре.

Это позволяет избежать ситуаций, когда одно ядро загружено на 100%, а другое простаивает.

Причем, это справедливо для систем с большим количеством ядер. Например, его запускали
на чипах с 1024 ядрами, и эрланг эффективно использовал ресурс всех этих ядер.

Erlang Scheduler Details and Why It Matters
https://hamidreza-s.github.io/erlang/scheduling/real-time/preemptive/migration/2016/02/09/erlang-scheduler-details.html


### Actor Model

https://en.wikipedia.org/wiki/Actor_model

Один из способов реализации многопоточности.

Система состоит из акторов, которые действуют паралельно и независимо друг от друга.

Акторы общаются друг с другом с помощью отправки сообщений (message passing).
Один поток может послать другому любые данные.
При этом данные копируются, и получающий поток никак не может повлиять на данные отправителя.

Отправка сообщений является асинхронной.
При необходимости можно реализовать синхронный вызов -- блокировать процесс на какое-то время, и ждать, пока придет ответное сообщение.

Каждый актор имеет mailbox, где накапливаются полученные им сообщения.
Это специальная область памяти процесса.
Процесс проверяет свой mailbox, когда считает нужным, и реагирует на сообщения, как считает нужным.

Для некоторых языков модель акторов реализована как библиотека.
Например, библиотека Akka http://akka.io/ для Scala и Java.

Но в эрланг эта модель реализована в виртуальной машине и поддерживается непосредственно на уровне языка.


### Soft Real Time

https://en.wikipedia.org/wiki/Real-time_computing

На эрланг можно строить системы реального времени -- то есть, системы, где требуется предсказуемое время ответа.

Это возможно благодаря:
- вытесняющей многозадачности (preemptive scheduling);
- настраиваемому IO;
- особенностям сборки мусора (garbage collection).

Да, планировщики в эрланг реализуют вытесняющую многозадачность.

IO не выполняется в каждом процессе отдельно, а выполняется через специализированный пул процессов,
и его можно тонко настраивать.

Про сборку мусора поговорим отдельно.


### Garbage Collection

Сборка мусора в функциональных языках несколько проще, чем в
императивных, благодаря неизменяемым переменным.  Из-за этого точно
известно, что переменные, созданные раньше, не могут указывать на
объекты, созданные позже.

Сборщик мусора в Erlang делит объекты на два поколения: молодые и
старые. И исходит из предположения, что большинство молодых объектов
являются короткоживущими, и для них память нужно чистить чаще. А
большинство старых объектов являются долгоживущими, и для них память
можно чистить реже.

В этом нет ничего особенного, во многих других языках сборка мусора работает аналогично.

А вот что в эрланг особенного, это отдельный сборщик мусора для каждого процесса.
В Erlang все сборщики работают независимо друг от друга, в разные моменты времени, и останавливают только свой процесс.
И отсюда отсутствие эффекта stop world, когда сборщик мусора должен остановить всю ноду для своей работы.

Если поток короткоживущий (что довольно обычно для Erlang),
то после его завершения вся память потока целиком освобождается, а сборщик мусора даже не успевает поработать.

Если поток долгоживущий, но потребляет мало памяти (типично для супервизора и других потоков, выполняющих "менеджерские" задачи),
то в нем сборщик мусора запускается очень редко, или никогда.

В результате сборка мусора оказывает мало влияния на производительность системы.

Erlang Garbage Collection Details and Why It Matters
https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html


### Erlang Shell

Как и многие другие языки, эрланг имеет REPL консоль.
Ей удобно пользоваться при разработке.

Но ей можно пользоваться и в продакшен. Можно подключиться к работающей ноде,
вызывать любую функцию любого модуля, отправить сообщение любому процессу,
прочитать и изменить состояние любого процесса -- то есть,
взаимодействовать с нодой в реальном времени.

Это очень помогает в диагностике разных проблем и исправлении их налету.


### Tracing

В эрланг есть встроенный на самом низком уровне механизм трассировки,
мало влияющий на общую производительность системы. Поэтому его можно
использовать на живой, продакшен системе.

Этот механизм позволяет получать в реальном времени информацию:
- жизненный цикл процессов (старт, остановка, связи с другими процессами);
- отправка и получение сообщений;
- вызовы функций, аргументы, возвращаемые значения, откуда вызвана;
- наблюдать состояние процессов, и менять его;
- информацию о работе планировщика;
- информацию о потреблении памяти и работе сборщиков мусора.

Теоретически можно узнать почти все о работе ноды. Практически этой
информации очень много, и сложность в том, чтобы выбрать именно ту, которая важна.

Данные трассировки можно наблюдать в консоли, или перенаправить в
файл, или в свой обработчик. Ее можно получать на той же ноде, или
перенаправить на другую ноду, и обрабатывать и анализировать там.
