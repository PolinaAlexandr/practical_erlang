## Дерево супервизоров

Давайте запустим дерево из супервизоров и рабочих процессов.

```
              main_sup
             /        \
        sup_1         sup_2
        /   \         /  \
    worker worker worker worker
```

Нам понадобится 4 модуля. 3 модуля-супервизора: **main_sup**, **sup_1**, **sup_2** и один модуль gen_server **worker**.

**main_sup** запускает два дочерних супервизора: sup\_1 и sup\_2. Каждый из дочерних супервизоров запускает по два потока worker.

Каждый worker на старте получает от родителя некий свой **Id** и сохраняет его.
Еще он должен иметь функцию **ping/1**, которая возвращает кортеж _{Id, Pid}_.

```
    > worker:ping(Pid).
    {worker_4,<0.42.0>}
```

**sup_2** должен зарегистрироваться под именем своего модуля, и реализовать функции **add_worker/1** и **remove_worker/1**,
позволяющие динамически добавлять к нему и удалять рабочие потоки.

```
    > sup2:add_worker(worker_5).
    {ok,<0.47.0>}
    > sup2:remove_worker(worker_5).
    ok
```

**add_worker** принимает некий идентификатор (любой term), по которому **remove_worker** может удалить рабочий поток.
Нужно не просто остановить рабочий поток, но и удалить его child_specification.

Для этого нужно разобраться, что делает функция **supervisor:terminate_child/2**,
и что делает **supervisor:delete_child/2**.
А понять, какие дочерние потоки есть у данного супервизора поможет функция **supervisor:which_children/1**.
