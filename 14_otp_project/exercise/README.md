# OTP проект

Пора взяться за полноценный OTP проект. На этот раз у вас не будет
готовых модулей, куда нужно добавить свой код.  Вы начинаете с чистого
листа -- пустого каталога. И вам нужно самим создать необходимую
структуру каталогов и файлов, а также наладить сборку и запуск
проекта.

Честно говоря, лист не совсем уж чистый. Есть **Makefile**, где описана
сборка проекта и запуск тестов, исходя из некоторых предположений о
структуре проекта:

- исходные коды находятся в папке **src**;
- заголовочные файлы в папке **include**;
- тесты в папке **test**;
- beam-файлы при сборке кладутся в папку **ebin**;
- там же находится файл ресурсов;
- присутствует файл настроек и он подключается при запуске ноды.

Вам не обязательно нужно следовать этим предположениям, но иначе
придется что-то исправлять в **Makefile**. (Смотрите, не поломайте
запуск тестов, если будете там что-то менять :)


## Приложение my_crypt

Проект состоит из одного приложения -- **my_crypt**.
Приложение может иметь любую структуру, состоять из любых модулей,
но в нем должен присутствовать модуль **my_crypt**, и в нем функции
**encode/1**, **get_key/0**, **set_key/1**, **hash/1**.
(Они будут вызываться из тестов).

Вероятно понадобится минимум один gen\_server, чтобы хранить некое
состояние приложения; supervisor, чтобы запустить gen\_server и
application-модуль, чтобы запустить все приложение.

У приложения будут настройки. Две из них обязательные
(описаны ниже), остальные по вашему усмотрению.

Как понятно из названия, приложение предоставляет некоторые
криптографические функции.  Вероятно вам понадобятся модули
[rand](http://erlang.org/doc/man/rand.html) и
[crypto](http://erlang.org/doc/man/crypto.html).


## Шифрование XOR

Один из простых способов шифрования -- это применение операции XOR.
У нас есть некие исходные данные, которые мы хотим зашифровать:

```
Bin = <<"Зарплата Васи Пупкина 100500 рублей">>.
```

И некий секретный ключ:

```
EncodeKey = <<"GVXLCLF4nJ5qtcAHQHmx">>.
```

Вы берете первый байт данных и первый байт ключа, применяете к ним
XOR, получаете байт зашифрованных данных.  Затем берете следующую пару
байтов, и так далее.

Обычно ключ короче, чем данные. Поэтому, когда байты ключа закончатся,
нужно вернуться к его началу, опять взять первый байт ключа, и так
далее, по кругу.

Особенность XOR в том, что если его применить к зашифрованным данным с
тем же ключом, то на выходе получатся исходные данные. Поэтому одна и
та же операция является и шифрованием, и дешифрованием.

Реализуйте 3 функции:

**my_crypt:encode/1** -- принимает на вход исходные данные (binary) и
возвращает зашифрованные данные (binary).

**my_crypt:get_key/0** -- возвращает текущее значение ключа шифрования (binary).

**my_crypt:set_key/1** -- задает новое значение ключа шифрования (binary).

В приложении должна быть настройка **encode_key** типа binary(), которая
используется как текущий ключ, пока не задан другой ключ.


## Генерация хэша

Приложение my_crypt также должно уметь генерировать уникальные хэши
для бинарных данных.

Реализуйте функцию **my_crypt:hash/1**, которая принимает на вход
исходные данные (binary) и возвращает хэш для них (binary).

Разумеется, одни и те же данные всегда должны давать один и тот же
хэш. И хэши для разных данных не должны совпадать.

Впрочем, большой устойчивости к коллизиям не требуется. Тесты в этом задании 
не проверяют уникальность хэшей для миллиардов строк. Поэтому очень уж 
надежные алгоритмы хэширования не нужны.

Алгоритм можете придумать сами или реализовать какой-либо известный.
Например, в моем решении используется
[хеширование Пирсона](https://en.wikipedia.org/wiki/Pearson_hashing).

Но, пожалуйста, не пользуйтесь
[erlang:md5/1](http://erlang.org/doc/man/erlang.html#md5-1),
[erlang:phash2/1](http://erlang.org/doc/man/erlang.html#phash2-1)
и другими встроенными реализациями, иначе упражнение потеряет смысл.

Если вы используете генерацию случайных значений, то важно, чтобы одни
и те же данные давали один и тот же хеш при перезапуске ноды.

Допустим, для данных <<"My Cool Data">> мы получим хэш <<1,2,3,4>>.
Потом остановим ноду, запустим ее заново. Потом опять генерируем хэш
для <<"My Cool Data">>. Хэш должен получиться таким же, <<1,2,3,4>>.

Тут нужно разобраться с [random:seed/3](http://erlang.org/doc/man/random.html#seed-3).
